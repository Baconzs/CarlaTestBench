// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: control/chassis.proto

#ifndef PROTOBUF_INCLUDED_control_2fchassis_2eproto
#define PROTOBUF_INCLUDED_control_2fchassis_2eproto

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 3006001
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 3006001 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/inlined_string_field.h>
#include <google/protobuf/metadata.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/unknown_field_set.h>
#include "common/header.pb.h"
#include "common/geometry.pb.h"
#include "common/wheel.pb.h"
// @@protoc_insertion_point(includes)
#define PROTOBUF_INTERNAL_EXPORT_protobuf_control_2fchassis_2eproto 

namespace protobuf_control_2fchassis_2eproto {
// Internal implementation detail -- do not use these members.
struct TableStruct {
  static const ::google::protobuf::internal::ParseTableField entries[];
  static const ::google::protobuf::internal::AuxillaryParseTableField aux[];
  static const ::google::protobuf::internal::ParseTable schema[3];
  static const ::google::protobuf::internal::FieldMetadata field_metadata[];
  static const ::google::protobuf::internal::SerializationTable serialization_table[];
  static const ::google::protobuf::uint32 offsets[];
};
void AddDescriptors();
}  // namespace protobuf_control_2fchassis_2eproto
namespace chassis {
class EPS;
class EPSDefaultTypeInternal;
extern EPSDefaultTypeInternal _EPS_default_instance_;
class ESP;
class ESPDefaultTypeInternal;
extern ESPDefaultTypeInternal _ESP_default_instance_;
class Powertrain;
class PowertrainDefaultTypeInternal;
extern PowertrainDefaultTypeInternal _Powertrain_default_instance_;
}  // namespace chassis
namespace google {
namespace protobuf {
template<> ::chassis::EPS* Arena::CreateMaybeMessage<::chassis::EPS>(Arena*);
template<> ::chassis::ESP* Arena::CreateMaybeMessage<::chassis::ESP>(Arena*);
template<> ::chassis::Powertrain* Arena::CreateMaybeMessage<::chassis::Powertrain>(Arena*);
}  // namespace protobuf
}  // namespace google
namespace chassis {

// ===================================================================

class ESP : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:chassis.ESP) */ {
 public:
  ESP();
  virtual ~ESP();

  ESP(const ESP& from);

  inline ESP& operator=(const ESP& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  ESP(ESP&& from) noexcept
    : ESP() {
    *this = ::std::move(from);
  }

  inline ESP& operator=(ESP&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const ESP& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ESP* internal_default_instance() {
    return reinterpret_cast<const ESP*>(
               &_ESP_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  void Swap(ESP* other);
  friend void swap(ESP& a, ESP& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ESP* New() const final {
    return CreateMaybeMessage<ESP>(NULL);
  }

  ESP* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<ESP>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const ESP& from);
  void MergeFrom(const ESP& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ESP* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .common.wheel wheel = 7;
  int wheel_size() const;
  void clear_wheel();
  static const int kWheelFieldNumber = 7;
  ::common::wheel* mutable_wheel(int index);
  ::google::protobuf::RepeatedPtrField< ::common::wheel >*
      mutable_wheel();
  const ::common::wheel& wheel(int index) const;
  ::common::wheel* add_wheel();
  const ::google::protobuf::RepeatedPtrField< ::common::wheel >&
      wheel() const;

  // .common.Header header = 1;
  bool has_header() const;
  void clear_header();
  static const int kHeaderFieldNumber = 1;
  private:
  const ::common::Header& _internal_header() const;
  public:
  const ::common::Header& header() const;
  ::common::Header* release_header();
  ::common::Header* mutable_header();
  void set_allocated_header(::common::Header* header);

  // .common.Point3D center_of_mass = 6;
  bool has_center_of_mass() const;
  void clear_center_of_mass();
  static const int kCenterOfMassFieldNumber = 6;
  private:
  const ::common::Point3D& _internal_center_of_mass() const;
  public:
  const ::common::Point3D& center_of_mass() const;
  ::common::Point3D* release_center_of_mass();
  ::common::Point3D* mutable_center_of_mass();
  void set_allocated_center_of_mass(::common::Point3D* center_of_mass);

  // float brake = 2;
  void clear_brake();
  static const int kBrakeFieldNumber = 2;
  float brake() const;
  void set_brake(float value);

  // bool hand_brake = 3;
  void clear_hand_brake();
  static const int kHandBrakeFieldNumber = 3;
  bool hand_brake() const;
  void set_hand_brake(bool value);

  // float mass = 4;
  void clear_mass();
  static const int kMassFieldNumber = 4;
  float mass() const;
  void set_mass(float value);

  // float drag_coefficient = 5;
  void clear_drag_coefficient();
  static const int kDragCoefficientFieldNumber = 5;
  float drag_coefficient() const;
  void set_drag_coefficient(float value);

  // float speed = 8;
  void clear_speed();
  static const int kSpeedFieldNumber = 8;
  float speed() const;
  void set_speed(float value);

  // @@protoc_insertion_point(class_scope:chassis.ESP)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedPtrField< ::common::wheel > wheel_;
  ::common::Header* header_;
  ::common::Point3D* center_of_mass_;
  float brake_;
  bool hand_brake_;
  float mass_;
  float drag_coefficient_;
  float speed_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_control_2fchassis_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class EPS : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:chassis.EPS) */ {
 public:
  EPS();
  virtual ~EPS();

  EPS(const EPS& from);

  inline EPS& operator=(const EPS& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  EPS(EPS&& from) noexcept
    : EPS() {
    *this = ::std::move(from);
  }

  inline EPS& operator=(EPS&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const EPS& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const EPS* internal_default_instance() {
    return reinterpret_cast<const EPS*>(
               &_EPS_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  void Swap(EPS* other);
  friend void swap(EPS& a, EPS& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline EPS* New() const final {
    return CreateMaybeMessage<EPS>(NULL);
  }

  EPS* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<EPS>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const EPS& from);
  void MergeFrom(const EPS& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(EPS* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .common.Header header = 1;
  bool has_header() const;
  void clear_header();
  static const int kHeaderFieldNumber = 1;
  private:
  const ::common::Header& _internal_header() const;
  public:
  const ::common::Header& header() const;
  ::common::Header* release_header();
  ::common::Header* mutable_header();
  void set_allocated_header(::common::Header* header);

  // float steer = 2;
  void clear_steer();
  static const int kSteerFieldNumber = 2;
  float steer() const;
  void set_steer(float value);

  // @@protoc_insertion_point(class_scope:chassis.EPS)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::common::Header* header_;
  float steer_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_control_2fchassis_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class Powertrain : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:chassis.Powertrain) */ {
 public:
  Powertrain();
  virtual ~Powertrain();

  Powertrain(const Powertrain& from);

  inline Powertrain& operator=(const Powertrain& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Powertrain(Powertrain&& from) noexcept
    : Powertrain() {
    *this = ::std::move(from);
  }

  inline Powertrain& operator=(Powertrain&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const Powertrain& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Powertrain* internal_default_instance() {
    return reinterpret_cast<const Powertrain*>(
               &_Powertrain_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  void Swap(Powertrain* other);
  friend void swap(Powertrain& a, Powertrain& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Powertrain* New() const final {
    return CreateMaybeMessage<Powertrain>(NULL);
  }

  Powertrain* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<Powertrain>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const Powertrain& from);
  void MergeFrom(const Powertrain& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Powertrain* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .common.Header header = 1;
  bool has_header() const;
  void clear_header();
  static const int kHeaderFieldNumber = 1;
  private:
  const ::common::Header& _internal_header() const;
  public:
  const ::common::Header& header() const;
  ::common::Header* release_header();
  ::common::Header* mutable_header();
  void set_allocated_header(::common::Header* header);

  // float throttle = 2;
  void clear_throttle();
  static const int kThrottleFieldNumber = 2;
  float throttle() const;
  void set_throttle(float value);

  // int32 gear = 3;
  void clear_gear();
  static const int kGearFieldNumber = 3;
  ::google::protobuf::int32 gear() const;
  void set_gear(::google::protobuf::int32 value);

  // float max_rpm = 5;
  void clear_max_rpm();
  static const int kMaxRpmFieldNumber = 5;
  float max_rpm() const;
  void set_max_rpm(float value);

  // float moi = 6;
  void clear_moi();
  static const int kMoiFieldNumber = 6;
  float moi() const;
  void set_moi(float value);

  // float damping_rate_full_throttle = 7;
  void clear_damping_rate_full_throttle();
  static const int kDampingRateFullThrottleFieldNumber = 7;
  float damping_rate_full_throttle() const;
  void set_damping_rate_full_throttle(float value);

  // bool manual_gear_shift = 4;
  void clear_manual_gear_shift();
  static const int kManualGearShiftFieldNumber = 4;
  bool manual_gear_shift() const;
  void set_manual_gear_shift(bool value);

  // bool use_gear_autobox = 10;
  void clear_use_gear_autobox();
  static const int kUseGearAutoboxFieldNumber = 10;
  bool use_gear_autobox() const;
  void set_use_gear_autobox(bool value);

  // float damping_rate_zero_throttle_clutch_engaged = 8;
  void clear_damping_rate_zero_throttle_clutch_engaged();
  static const int kDampingRateZeroThrottleClutchEngagedFieldNumber = 8;
  float damping_rate_zero_throttle_clutch_engaged() const;
  void set_damping_rate_zero_throttle_clutch_engaged(float value);

  // float damping_rate_zero_throttle_clutch_disengaged = 9;
  void clear_damping_rate_zero_throttle_clutch_disengaged();
  static const int kDampingRateZeroThrottleClutchDisengagedFieldNumber = 9;
  float damping_rate_zero_throttle_clutch_disengaged() const;
  void set_damping_rate_zero_throttle_clutch_disengaged(float value);

  // float gear_switch_time = 11;
  void clear_gear_switch_time();
  static const int kGearSwitchTimeFieldNumber = 11;
  float gear_switch_time() const;
  void set_gear_switch_time(float value);

  // float clutch_strength = 12;
  void clear_clutch_strength();
  static const int kClutchStrengthFieldNumber = 12;
  float clutch_strength() const;
  void set_clutch_strength(float value);

  // @@protoc_insertion_point(class_scope:chassis.Powertrain)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::common::Header* header_;
  float throttle_;
  ::google::protobuf::int32 gear_;
  float max_rpm_;
  float moi_;
  float damping_rate_full_throttle_;
  bool manual_gear_shift_;
  bool use_gear_autobox_;
  float damping_rate_zero_throttle_clutch_engaged_;
  float damping_rate_zero_throttle_clutch_disengaged_;
  float gear_switch_time_;
  float clutch_strength_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_control_2fchassis_2eproto::TableStruct;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// ESP

// .common.Header header = 1;
inline bool ESP::has_header() const {
  return this != internal_default_instance() && header_ != NULL;
}
inline const ::common::Header& ESP::_internal_header() const {
  return *header_;
}
inline const ::common::Header& ESP::header() const {
  const ::common::Header* p = header_;
  // @@protoc_insertion_point(field_get:chassis.ESP.header)
  return p != NULL ? *p : *reinterpret_cast<const ::common::Header*>(
      &::common::_Header_default_instance_);
}
inline ::common::Header* ESP::release_header() {
  // @@protoc_insertion_point(field_release:chassis.ESP.header)
  
  ::common::Header* temp = header_;
  header_ = NULL;
  return temp;
}
inline ::common::Header* ESP::mutable_header() {
  
  if (header_ == NULL) {
    auto* p = CreateMaybeMessage<::common::Header>(GetArenaNoVirtual());
    header_ = p;
  }
  // @@protoc_insertion_point(field_mutable:chassis.ESP.header)
  return header_;
}
inline void ESP::set_allocated_header(::common::Header* header) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(header_);
  }
  if (header) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      header = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, header, submessage_arena);
    }
    
  } else {
    
  }
  header_ = header;
  // @@protoc_insertion_point(field_set_allocated:chassis.ESP.header)
}

// float brake = 2;
inline void ESP::clear_brake() {
  brake_ = 0;
}
inline float ESP::brake() const {
  // @@protoc_insertion_point(field_get:chassis.ESP.brake)
  return brake_;
}
inline void ESP::set_brake(float value) {
  
  brake_ = value;
  // @@protoc_insertion_point(field_set:chassis.ESP.brake)
}

// bool hand_brake = 3;
inline void ESP::clear_hand_brake() {
  hand_brake_ = false;
}
inline bool ESP::hand_brake() const {
  // @@protoc_insertion_point(field_get:chassis.ESP.hand_brake)
  return hand_brake_;
}
inline void ESP::set_hand_brake(bool value) {
  
  hand_brake_ = value;
  // @@protoc_insertion_point(field_set:chassis.ESP.hand_brake)
}

// float mass = 4;
inline void ESP::clear_mass() {
  mass_ = 0;
}
inline float ESP::mass() const {
  // @@protoc_insertion_point(field_get:chassis.ESP.mass)
  return mass_;
}
inline void ESP::set_mass(float value) {
  
  mass_ = value;
  // @@protoc_insertion_point(field_set:chassis.ESP.mass)
}

// float drag_coefficient = 5;
inline void ESP::clear_drag_coefficient() {
  drag_coefficient_ = 0;
}
inline float ESP::drag_coefficient() const {
  // @@protoc_insertion_point(field_get:chassis.ESP.drag_coefficient)
  return drag_coefficient_;
}
inline void ESP::set_drag_coefficient(float value) {
  
  drag_coefficient_ = value;
  // @@protoc_insertion_point(field_set:chassis.ESP.drag_coefficient)
}

// .common.Point3D center_of_mass = 6;
inline bool ESP::has_center_of_mass() const {
  return this != internal_default_instance() && center_of_mass_ != NULL;
}
inline const ::common::Point3D& ESP::_internal_center_of_mass() const {
  return *center_of_mass_;
}
inline const ::common::Point3D& ESP::center_of_mass() const {
  const ::common::Point3D* p = center_of_mass_;
  // @@protoc_insertion_point(field_get:chassis.ESP.center_of_mass)
  return p != NULL ? *p : *reinterpret_cast<const ::common::Point3D*>(
      &::common::_Point3D_default_instance_);
}
inline ::common::Point3D* ESP::release_center_of_mass() {
  // @@protoc_insertion_point(field_release:chassis.ESP.center_of_mass)
  
  ::common::Point3D* temp = center_of_mass_;
  center_of_mass_ = NULL;
  return temp;
}
inline ::common::Point3D* ESP::mutable_center_of_mass() {
  
  if (center_of_mass_ == NULL) {
    auto* p = CreateMaybeMessage<::common::Point3D>(GetArenaNoVirtual());
    center_of_mass_ = p;
  }
  // @@protoc_insertion_point(field_mutable:chassis.ESP.center_of_mass)
  return center_of_mass_;
}
inline void ESP::set_allocated_center_of_mass(::common::Point3D* center_of_mass) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(center_of_mass_);
  }
  if (center_of_mass) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      center_of_mass = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, center_of_mass, submessage_arena);
    }
    
  } else {
    
  }
  center_of_mass_ = center_of_mass;
  // @@protoc_insertion_point(field_set_allocated:chassis.ESP.center_of_mass)
}

// repeated .common.wheel wheel = 7;
inline int ESP::wheel_size() const {
  return wheel_.size();
}
inline ::common::wheel* ESP::mutable_wheel(int index) {
  // @@protoc_insertion_point(field_mutable:chassis.ESP.wheel)
  return wheel_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::common::wheel >*
ESP::mutable_wheel() {
  // @@protoc_insertion_point(field_mutable_list:chassis.ESP.wheel)
  return &wheel_;
}
inline const ::common::wheel& ESP::wheel(int index) const {
  // @@protoc_insertion_point(field_get:chassis.ESP.wheel)
  return wheel_.Get(index);
}
inline ::common::wheel* ESP::add_wheel() {
  // @@protoc_insertion_point(field_add:chassis.ESP.wheel)
  return wheel_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::common::wheel >&
ESP::wheel() const {
  // @@protoc_insertion_point(field_list:chassis.ESP.wheel)
  return wheel_;
}

// float speed = 8;
inline void ESP::clear_speed() {
  speed_ = 0;
}
inline float ESP::speed() const {
  // @@protoc_insertion_point(field_get:chassis.ESP.speed)
  return speed_;
}
inline void ESP::set_speed(float value) {
  
  speed_ = value;
  // @@protoc_insertion_point(field_set:chassis.ESP.speed)
}

// -------------------------------------------------------------------

// EPS

// .common.Header header = 1;
inline bool EPS::has_header() const {
  return this != internal_default_instance() && header_ != NULL;
}
inline const ::common::Header& EPS::_internal_header() const {
  return *header_;
}
inline const ::common::Header& EPS::header() const {
  const ::common::Header* p = header_;
  // @@protoc_insertion_point(field_get:chassis.EPS.header)
  return p != NULL ? *p : *reinterpret_cast<const ::common::Header*>(
      &::common::_Header_default_instance_);
}
inline ::common::Header* EPS::release_header() {
  // @@protoc_insertion_point(field_release:chassis.EPS.header)
  
  ::common::Header* temp = header_;
  header_ = NULL;
  return temp;
}
inline ::common::Header* EPS::mutable_header() {
  
  if (header_ == NULL) {
    auto* p = CreateMaybeMessage<::common::Header>(GetArenaNoVirtual());
    header_ = p;
  }
  // @@protoc_insertion_point(field_mutable:chassis.EPS.header)
  return header_;
}
inline void EPS::set_allocated_header(::common::Header* header) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(header_);
  }
  if (header) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      header = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, header, submessage_arena);
    }
    
  } else {
    
  }
  header_ = header;
  // @@protoc_insertion_point(field_set_allocated:chassis.EPS.header)
}

// float steer = 2;
inline void EPS::clear_steer() {
  steer_ = 0;
}
inline float EPS::steer() const {
  // @@protoc_insertion_point(field_get:chassis.EPS.steer)
  return steer_;
}
inline void EPS::set_steer(float value) {
  
  steer_ = value;
  // @@protoc_insertion_point(field_set:chassis.EPS.steer)
}

// -------------------------------------------------------------------

// Powertrain

// .common.Header header = 1;
inline bool Powertrain::has_header() const {
  return this != internal_default_instance() && header_ != NULL;
}
inline const ::common::Header& Powertrain::_internal_header() const {
  return *header_;
}
inline const ::common::Header& Powertrain::header() const {
  const ::common::Header* p = header_;
  // @@protoc_insertion_point(field_get:chassis.Powertrain.header)
  return p != NULL ? *p : *reinterpret_cast<const ::common::Header*>(
      &::common::_Header_default_instance_);
}
inline ::common::Header* Powertrain::release_header() {
  // @@protoc_insertion_point(field_release:chassis.Powertrain.header)
  
  ::common::Header* temp = header_;
  header_ = NULL;
  return temp;
}
inline ::common::Header* Powertrain::mutable_header() {
  
  if (header_ == NULL) {
    auto* p = CreateMaybeMessage<::common::Header>(GetArenaNoVirtual());
    header_ = p;
  }
  // @@protoc_insertion_point(field_mutable:chassis.Powertrain.header)
  return header_;
}
inline void Powertrain::set_allocated_header(::common::Header* header) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(header_);
  }
  if (header) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      header = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, header, submessage_arena);
    }
    
  } else {
    
  }
  header_ = header;
  // @@protoc_insertion_point(field_set_allocated:chassis.Powertrain.header)
}

// float throttle = 2;
inline void Powertrain::clear_throttle() {
  throttle_ = 0;
}
inline float Powertrain::throttle() const {
  // @@protoc_insertion_point(field_get:chassis.Powertrain.throttle)
  return throttle_;
}
inline void Powertrain::set_throttle(float value) {
  
  throttle_ = value;
  // @@protoc_insertion_point(field_set:chassis.Powertrain.throttle)
}

// int32 gear = 3;
inline void Powertrain::clear_gear() {
  gear_ = 0;
}
inline ::google::protobuf::int32 Powertrain::gear() const {
  // @@protoc_insertion_point(field_get:chassis.Powertrain.gear)
  return gear_;
}
inline void Powertrain::set_gear(::google::protobuf::int32 value) {
  
  gear_ = value;
  // @@protoc_insertion_point(field_set:chassis.Powertrain.gear)
}

// bool manual_gear_shift = 4;
inline void Powertrain::clear_manual_gear_shift() {
  manual_gear_shift_ = false;
}
inline bool Powertrain::manual_gear_shift() const {
  // @@protoc_insertion_point(field_get:chassis.Powertrain.manual_gear_shift)
  return manual_gear_shift_;
}
inline void Powertrain::set_manual_gear_shift(bool value) {
  
  manual_gear_shift_ = value;
  // @@protoc_insertion_point(field_set:chassis.Powertrain.manual_gear_shift)
}

// float max_rpm = 5;
inline void Powertrain::clear_max_rpm() {
  max_rpm_ = 0;
}
inline float Powertrain::max_rpm() const {
  // @@protoc_insertion_point(field_get:chassis.Powertrain.max_rpm)
  return max_rpm_;
}
inline void Powertrain::set_max_rpm(float value) {
  
  max_rpm_ = value;
  // @@protoc_insertion_point(field_set:chassis.Powertrain.max_rpm)
}

// float moi = 6;
inline void Powertrain::clear_moi() {
  moi_ = 0;
}
inline float Powertrain::moi() const {
  // @@protoc_insertion_point(field_get:chassis.Powertrain.moi)
  return moi_;
}
inline void Powertrain::set_moi(float value) {
  
  moi_ = value;
  // @@protoc_insertion_point(field_set:chassis.Powertrain.moi)
}

// float damping_rate_full_throttle = 7;
inline void Powertrain::clear_damping_rate_full_throttle() {
  damping_rate_full_throttle_ = 0;
}
inline float Powertrain::damping_rate_full_throttle() const {
  // @@protoc_insertion_point(field_get:chassis.Powertrain.damping_rate_full_throttle)
  return damping_rate_full_throttle_;
}
inline void Powertrain::set_damping_rate_full_throttle(float value) {
  
  damping_rate_full_throttle_ = value;
  // @@protoc_insertion_point(field_set:chassis.Powertrain.damping_rate_full_throttle)
}

// float damping_rate_zero_throttle_clutch_engaged = 8;
inline void Powertrain::clear_damping_rate_zero_throttle_clutch_engaged() {
  damping_rate_zero_throttle_clutch_engaged_ = 0;
}
inline float Powertrain::damping_rate_zero_throttle_clutch_engaged() const {
  // @@protoc_insertion_point(field_get:chassis.Powertrain.damping_rate_zero_throttle_clutch_engaged)
  return damping_rate_zero_throttle_clutch_engaged_;
}
inline void Powertrain::set_damping_rate_zero_throttle_clutch_engaged(float value) {
  
  damping_rate_zero_throttle_clutch_engaged_ = value;
  // @@protoc_insertion_point(field_set:chassis.Powertrain.damping_rate_zero_throttle_clutch_engaged)
}

// float damping_rate_zero_throttle_clutch_disengaged = 9;
inline void Powertrain::clear_damping_rate_zero_throttle_clutch_disengaged() {
  damping_rate_zero_throttle_clutch_disengaged_ = 0;
}
inline float Powertrain::damping_rate_zero_throttle_clutch_disengaged() const {
  // @@protoc_insertion_point(field_get:chassis.Powertrain.damping_rate_zero_throttle_clutch_disengaged)
  return damping_rate_zero_throttle_clutch_disengaged_;
}
inline void Powertrain::set_damping_rate_zero_throttle_clutch_disengaged(float value) {
  
  damping_rate_zero_throttle_clutch_disengaged_ = value;
  // @@protoc_insertion_point(field_set:chassis.Powertrain.damping_rate_zero_throttle_clutch_disengaged)
}

// bool use_gear_autobox = 10;
inline void Powertrain::clear_use_gear_autobox() {
  use_gear_autobox_ = false;
}
inline bool Powertrain::use_gear_autobox() const {
  // @@protoc_insertion_point(field_get:chassis.Powertrain.use_gear_autobox)
  return use_gear_autobox_;
}
inline void Powertrain::set_use_gear_autobox(bool value) {
  
  use_gear_autobox_ = value;
  // @@protoc_insertion_point(field_set:chassis.Powertrain.use_gear_autobox)
}

// float gear_switch_time = 11;
inline void Powertrain::clear_gear_switch_time() {
  gear_switch_time_ = 0;
}
inline float Powertrain::gear_switch_time() const {
  // @@protoc_insertion_point(field_get:chassis.Powertrain.gear_switch_time)
  return gear_switch_time_;
}
inline void Powertrain::set_gear_switch_time(float value) {
  
  gear_switch_time_ = value;
  // @@protoc_insertion_point(field_set:chassis.Powertrain.gear_switch_time)
}

// float clutch_strength = 12;
inline void Powertrain::clear_clutch_strength() {
  clutch_strength_ = 0;
}
inline float Powertrain::clutch_strength() const {
  // @@protoc_insertion_point(field_get:chassis.Powertrain.clutch_strength)
  return clutch_strength_;
}
inline void Powertrain::set_clutch_strength(float value) {
  
  clutch_strength_ = value;
  // @@protoc_insertion_point(field_set:chassis.Powertrain.clutch_strength)
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace chassis

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_INCLUDED_control_2fchassis_2eproto
